<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞ ‚Ññ2</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <h1>–ß—Ç–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</h1>

    <div class="controls">
      <label class="upload-btn">
        üìÇ –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª—ã
        <input type="file" id="fileInputFiles" accept="image/*" multiple hidden>
      </label>

      <label class="upload-btn">
        üìÅ –í—ã–±—Ä–∞—Ç—å –ø–∞–ø–∫—É
        <input type="file" id="fileInputFolder" accept="image/*" webkitdirectory multiple hidden>
      </label>
    </div>

    <div id="stats">
      <p>–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: <span id="fileCount">0</span> | –û–±—â–∏–π –æ–±—ä–µ–º: <span id="totalSize">0</span> –ú–ë</p>
      <div id="progressBar"><div id="progressFill"></div></div>
    </div>

    <div class="table-wrapper">
      <table id="resultTable">
        <thead>
          <tr>
            <th>–ò–º—è —Ñ–∞–π–ª–∞</th>
            <th>–§–æ—Ä–º–∞—Ç</th>
            <th>–†–∞–∑–º–µ—Ä</th>
            <th>–ì–ª—É–±–∏–Ω–∞ —Ü–≤–µ—Ç–∞</th>
            <th>–°–∂–∞—Ç–∏–µ</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script src="https://unpkg.com/exifreader@4.21.1/dist/exif-reader.js"></script>
  <script src="script.js"></script>
</body>
</html>
<style>body {
  font-family: "Segoe UI", sans-serif;
  background-color: #1e1e1e;
  color: #e0e0e0;
  margin: 0;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  padding-top: 40px;
}

.container {
  background: #2b2b2b;
  border-radius: 24px;
  padding: 30px 40px;
  box-shadow: 0 0 20px rgba(0,0,0,0.5);
  width: 95%;
  max-width: 1100px;
}

h1 {
  text-align: center;
  margin-bottom: 25px;
  font-size: 28px;
}

.controls {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 20px;
  margin-bottom: 25px;
}

.upload-btn {
  background-color: #3a3a3a;
  color: #fff;
  border: none;
  padding: 16px 36px;
  border-radius: 22px;
  font-size: 18px;
  cursor: pointer;
  transition: background 0.3s;
}

.upload-btn:hover {
  background-color: #505050;
}

#stats {
  text-align: center;
  margin-bottom: 20px;
  font-size: 16px;
}

#progressBar {
  width: 80%;
  margin: 10px auto;
  height: 18px;
  background-color: #3a3a3a;
  border-radius: 10px;
  overflow: hidden;
}

#progressBar div {
  height: 100%;
  width: 0%;
  background-color: #4caf50;
  transition: width 0.2s;
}

table {
  width: 100%;
  border-collapse: collapse;
  font-size: 16px;
}

th, td {
  padding: 14px;
  text-align: center;
  border-bottom: 1px solid #444;
}

th {
  background-color: #333;
}

tr:hover {
  background-color: #3c3c3c;
}
</style>
<script>
const fileInputFiles = document.getElementById('fileInputFiles');
const fileInputFolder = document.getElementById('fileInputFolder');
const tbody = document.querySelector('#resultTable tbody');
const fileCountEl = document.getElementById('fileCount');
const totalSizeEl = document.getElementById('totalSize');
const progressFill = document.getElementById('progressFill');

fileInputFiles.addEventListener('change', (e) => handleFileSelection(e.target.files));
fileInputFolder.addEventListener('change', (e) => handleFileSelection(e.target.files));

async function handleFileSelection(files) {
    const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
    if (imageFiles.length === 0) return;

    tbody.innerHTML = '';
    progressFill.style.width = '0%';
    let totalSize = 0;

    for (let i = 0; i < imageFiles.length; i++) {
        const file = imageFiles[i];
        
        try {
            const fileData = await processSingleFile(file);
            addTableRow(file, fileData);
            totalSize += file.size;
        } catch (error) {
            console.error(`–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ ${file.name}:`, error);
            addErrorRow(file);
        }

        fileCountEl.textContent = `${i + 1} / ${imageFiles.length}`;
        totalSizeEl.textContent = (totalSize / (1024 * 1024)).toFixed(2);
        progressFill.style.width = `${((i + 1) / imageFiles.length) * 100}%`;
    }
}

async function processSingleFile(file) {
    const [basicInfo, metaInfo] = await Promise.all([
        getBasicImageInfo(file),
        getMetaData(file)
    ]);
    
    const colorDepth = await getColorDepth(file, metaInfo);

    return {
        ...basicInfo,
        format: file.name.split('.').pop().toUpperCase(),
        compression: getCompression(file, metaInfo),
        colorDepth: colorDepth
    };
}

async function getColorDepth(file, meta) {
    const ext = file.name.split('.').pop().toLowerCase();

    if (ext === 'bmp') {
        const bmpDepth = await readBmpBitDepth(file);
        if (bmpDepth !== null) {
            console.log(`[–û–¢–õ–ê–î–ö–ê BMP] –§–∞–π–ª: ${file.name}. –ü—Ä–æ—á–∏—Ç–∞–Ω–Ω–∞—è –≥–ª—É–±–∏–Ω–∞: ${bmpDepth} –±–∏—Ç.`);
            return `${bmpDepth} –±–∏—Ç`;
        }
    }
    
    if (ext === 'png') {
        const pngDepth = await readPngBitDepth(file);
        if (pngDepth) return pngDepth;
    }   

    const bitsPerSample = meta?.ifd0?.BitsPerSample?.value;
    if (Array.isArray(bitsPerSample)) {
        return `${bitsPerSample.reduce((a, b) => a + b, 0)} –±–∏—Ç`;
    }

    if (ext === 'gif') return '8 –±–∏—Ç';
    if (ext === 'jpg' || ext === 'jpeg') return '24 –±–∏—Ç–∞';
    
    return '–ù/–î';
}

function readBmpBitDepth(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const dataView = new DataView(event.target.result);
                const bitDepth = dataView.getUint16(28, true);
                resolve(bitDepth);
            } catch {
                resolve(null);
            }
        };
        reader.onerror = () => resolve(null);
        reader.readAsArrayBuffer(file.slice(0, 30));
    });
}

async function readPngBitDepth(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const dataView = new DataView(event.target.result);

                const pngSignature = [0x89, 0x50, 0x4E, 0x47];
                for (let i = 0; i < 4; i++) {
                    if (dataView.getUint8(i) !== pngSignature[i]) {
                        resolve(null);
                        return;
                    }
                }

                const bitDepth = dataView.getUint8(24);
                const colorType = dataView.getUint8(25);

                let description = `${bitDepth} –±–∏—Ç`;
                if (colorType === 2) description = `${bitDepth * 3} –±–∏—Ç`;
                if (colorType === 6) description = `${bitDepth * 4} –±–∏—Ç`;
                if (colorType === 3) description = `${bitDepth} –±–∏—Ç (–∏–Ω–¥–µ–∫—Å.)`;

                resolve(description);
            } catch {
                resolve(null);
            }
        };
        reader.onerror = () => resolve(null);
        reader.readAsArrayBuffer(file.slice(0, 30));
    });
}


function getBasicImageInfo(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);
        img.onload = () => {
            URL.revokeObjectURL(url);
            resolve({ width: img.naturalWidth, height: img.naturalHeight });
        };
        img.onerror = () => {
            URL.revokeObjectURL(url);
            reject("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ä–∞–∑–º–µ—Ä—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è");
        };
        img.src = url;
    });
}

async function getMetaData(file) {
    try {
        if (typeof ExifReader === 'undefined') return null;
        return await ExifReader.load(file);
    } catch {
        return null;
    }
}

function getDpi(meta) {
    return meta?.ifd0?.XResolution?.description ? `${meta.ifd0.XResolution.description} dpi` : '‚Äî';
}

function getCompression(file, meta) {
    if (meta?.ifd0?.Compression?.description) return meta.ifd0.Compression.description;
    const ext = file.name.split('.').pop().toLowerCase();
    switch (ext) {
        case 'jpg': case 'jpeg': return 'JPEG';
        case 'png': return 'LZ77';
        case 'gif': return 'LZW';
        case 'bmp': return '–ë–µ–∑ —Å–∂–∞—Ç–∏—è';
    }
    return '–ù/–î';
}


function addTableRow(file, data) {
    const row = tbody.insertRow();
    row.innerHTML = `
        <td title="${file.webkitRelativePath || file.name}">${truncateName(file.name)}</td>
        <td>${data.format}</td>
        <td>${data.width} √ó ${data.height}</td>
        <td>${data.colorDepth}</td>
        <td>${data.compression}</td>
    `;
}

function addErrorRow(file) {
    const row = tbody.insertRow();
    row.style.color = '#ff8a8a';
    row.innerHTML = `<td>${truncateName(file.name)}</td><td colspan="4">–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª</td>`;
}

function truncateName(name) {
    if (name.length > 40) return `${name.substring(0, 20)}...${name.substring(name.length - 15)}`;
    return name;
}
</script>
